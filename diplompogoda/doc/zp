
Карта представляет из себя набор геометрических примитвов - линии границы государств. 
Для получения этих данных обратимся к популярному формату геоданных - shapefile. По сути shapefile позволяет хранить точки, линии, полигоны и другие объекты. Также может содержать информацию о параметрах объектов - названий, глубины населении.
Hа самом деле, shapefile представляет из себя набор из трёх файлов: с расширениями shp, shx dbf. 
Возьмём эти файлы с портала www.naturalearthdata.com предоставляющего доступ к свободным картографичеким данным.
А именно загрузим  карты территорий государств с границами по ссылке https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/cultural/ne_110m_admin_0_countries.zip
Полученный архив распакуем в рабочий каталог проекта и получим необходимые файлы.
Тем не менее данный формат не удобен для работы на клиентской стороне. Поэтому следует преобразовать полученные файлы в формат с которым удобно работать в Javascrip коде.
Для этого сперва конвертируем shapefiles-данные в GeoJSON утилитой ogr2ogr из библиотеки программ GDAL работающей с геоданными. Выполним следующую команду.
ogr2ogr -f GeoJSON world.json ne_10m_admin_0_countries.shp
Таким образом получается файл world.json в формате GeoJSON с границами государств.
Но для простой работы с этими данными используюя библиотеку визуализации D3.js лучше преобразовать данный файл в формат TopoJSON. Для этого устанавливается утилита topojson при помощи пакетного менедрежа для node.js следующим образом.
npm install topojson
После этого достаточно выполнить команду
topojson -o topoworld.json --id-property SU_A3 world.json
#geo2topo
В результате работы которой будет получен topoworld.json - результирующий TopoJSON-файл. Который и будет в дальнейшем загружен клиентом.


Для работы с библиотекой визуализации данных D3.js подключаются соответствующие скрипты.
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="https://d3js.org/d3-array.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <script src="http://d3js.org/d3.geo.projection.v0.min.js"></script>

Чтобы при вводе города была возможность выбирать город по частичному совпадению из предложенного списка подключается компонент Autocomplete из библиотек компонентов для пользовательского интрефейса jquery-ui. Подключение выполняется ссылкой на соответствующие скрипты.
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

Затем, в javascript коде страницы вызывается метод autocomplete у объекта выборки JQuery с параметром являющися css селектором поля ввода. При этом вызове передаётся список городов из по которому будет осуществляться поиск.
    $("#cities").autocomplete({
          source: cities_names
    });


Созданную HTML страницу разместим в подкаталоге templates. Эту страницу будет отдавать сервер по запросу клиента. 
Для этого определим обработчик в коде сервера который будет возвращаться данную HTML страницу.  Это реализуется следущим образом.
@app.route('/')
def root():
    return render_template('yandex.html')

Остальные клиентские файлы (стили css, код javascript, json данные) поместим в подкаталог static. Поскольку клиент будет запрашивать эти файлы добавим обработчик статических файлов из подкаталога static в коде сервера. Данный механизм реализуется вызовом метода send_from_directory микрофреймворка flask. 
@app.route('/static/<path:path>')
def send_static(path):
    return send_from_directory('static', path)


---------------------------------------------------------------------------------
Чтобы реализовать управление масштабом добавляются кнопки управления на страницу. Чтобы иметь возможность легко найти эти кнопки, устанавливаются значения аттрибута id. В HTML коде страницы кнопки выглядят следующим образом:
<input type=button value="+" id="scaleup" />
<input type=button value="-" id="scaledown" />

Далее, чтобы привязать поведение к нажатиям этих кнопок необходимо установить им значение аттрибута onclick. Этим значением будет функция, выполняющая соответственно увеличение или уменьшение масштаба. Для получения элементов кнопок воспользуемся jQuery функцией $ и передадим ей css селектор выбирающий требуемый элемент по аттрибуту id. У полученного jQuery объкта можно сразу вызвать метод on для привязки функции-обработчика на любое событие. В данном случае привязывается функция масштабирования на событие click. Данное действие выглядит следующим образом:
$("#scaleup").on("click", function() { scale_projection(SCALE_VAL) });
$("#scaledown").on("click", function() { scale_projection(-SCALE_VAL) });

Кроме возможности масштабирования нажатиями кнопок удобно это же действие продублировать на поворот колеса мыши. Событие поворота колеса мыши следует обрабатывать только на элементе карты чтобы не нарушать естественные функции этого события. 
Поскольку событие поворота колеса мыши было стандартизовано относительно недавно, разные браузры используют разные имена для него. Для обеспечения кроссбраузерности следует привязать функцию масштабирования на несколько событий. Этого можно достичь вызвом метода bind выбранного jQuery объекта с перечислением событий в строке в качестве параметра. 
Чтобы понимать направления поворота колеса мыши достаточно проверять знак значения смещения. Но это значение разное для разных браузеров. Следовательно нужно это учитывать и проверять их все. В итоге привязка на событие поворота колеса мыши выполняется так:
$("#map").bind('mousewheel DOMMouseScroll', function(event){
    if (event.originalEvent.wheelDelta > 0 || event.originalEvent.detail < 0) {
        scale_projection(SCALE_VAL/2);
    }
    else {
        scale_projection(-SCALE_VAL/2);
    }
});

https://desktop.arcgis.com/ru/arcmap/10.3/guide-books/map-projections/orthographic.htm
https://observablehq.com/collection/@d3/d3-geo

Географические данные содержат объекты представляющие собой множества точек с георафическими координатами - широтой и долготой. Нельзя напрямую отобразить эти точки на экране. Требуется преобразовать георафические координаты в экранные. Это можно сделать множеством способов, поэтому существует несколько картографических проекций. Для пользователя привычно видеть глобус в виде шара. Ближе всего к этому ортографическая проекция - которая является перспективной проекцией которая обозревает земной шар из бесконечности, что даёт реалистичную иллюзию трёхмерного глобуса.
Модуль geo библиотеки D3 содержит требуемую проекцию - d3.geo.orthographic. При помощи этой функции создаётся объект ортографической проекции. После чего следует настроить начальные параметры проекции. А именно установить масштаб - с помощью вызова метода scale, повернуть в нулевую точку с помощью метода rotate, переместить отображение в середину холста, установить угол отсечения вызовом метода clipAngle. Поскольку каждый вызов метода объекта d3 возвращает результирующий объект, то всё перечисленное можно организовать в цепочку вызовов. В итоге создание и настройка объекта проекции реализуется следующим вызовом:
projection = d3.geo.orthographic()
    .scale(380)
    .rotate([0, 0])
    .translate([width / 2, height / 2])
    .clipAngle(90);


?
    context = d3.select('#map canvas')
      .node()
      .getContext('2d', { alpha: false });



