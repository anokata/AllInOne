Чтобы реализовать управление масштабом добавляются кнопки управления на страницу. Чтобы иметь возможность легко найти эти кнопки, устанавливаются значения аттрибута id. В HTML коде страницы кнопки выглядят следующим образом:
<input type=button value="+" id="scaleup" />
<input type=button value="-" id="scaledown" />

Далее, чтобы привязать поведение к нажатиям этих кнопок необходимо установить им значение аттрибута onclick. Этим значением будет функция, выполняющая соответственно увеличение или уменьшение масштаба. Для получения элементов кнопок воспользуемся jQuery функцией $ и передадим ей css селектор выбирающий требуемый элемент по аттрибуту id. У полученного jQuery объкта можно сразу вызвать метод on для привязки функции-обработчика на любое событие. В данном случае привязывается функция масштабирования на событие click. Данное действие выглядит следующим образом:
$("#scaleup").on("click", function() { scale_projection(SCALE_VAL) });
$("#scaledown").on("click", function() { scale_projection(-SCALE_VAL) });

Кроме возможности масштабирования нажатиями кнопок удобно это же действие продублировать на поворот колеса мыши. Событие поворота колеса мыши следует обрабатывать только на элементе карты чтобы не нарушать естественные функции этого события. 
Поскольку событие поворота колеса мыши было стандартизовано относительно недавно, разные браузры используют разные имена для него. Для обеспечения кроссбраузерности следует привязать функцию масштабирования на несколько событий. Этого можно достичь вызвом метода bind выбранного jQuery объекта с перечислением событий в строке в качестве параметра. 
Чтобы понимать направления поворота колеса мыши достаточно проверять знак значения смещения. Но это значение разное для разных браузеров. Следовательно нужно это учитывать и проверять их все. В итоге привязка на событие поворота колеса мыши выполняется так:
$("#map").bind('mousewheel DOMMouseScroll', function(event){
    if (event.originalEvent.wheelDelta > 0 || event.originalEvent.detail < 0) {
        scale_projection(SCALE_VAL/2);
    }
    else {
        scale_projection(-SCALE_VAL/2);
    }
});

https://desktop.arcgis.com/ru/arcmap/10.3/guide-books/map-projections/orthographic.htm
https://observablehq.com/collection/@d3/d3-geo

Географические данные содержат объекты представляющие собой множества точек с георафическими координатами - широтой и долготой. Нельзя напрямую отобразить эти точки на экране. Требуется преобразовать георафические координаты в экранные. Это можно сделать множеством способов, поэтому существует несколько картографических проекций. Для пользователя привычно видеть глобус в виде шара. Ближе всего к этому ортографическая проекция - которая является перспективной проекцией которая обозревает земной шар из бесконечности, что даёт реалистичную иллюзию трёхмерного глобуса.
Модуль geo библиотеки D3 содержит требуемую проекцию - d3.geo.orthographic. При помощи этой функции создаётся объект ортографической проекции. После чего следует настроить начальные параметры проекции. А именно установить масштаб - с помощью вызова метода scale, повернуть в нулевую точку с помощью метода rotate, переместить отображение в середину холста, установить угол отсечения вызовом метода clipAngle. Поскольку каждый вызов метода объекта d3 возвращает результирующий объект, то всё перечисленное можно организовать в цепочку вызовов. В итоге создание и настройка объекта проекции реализуется следующим вызовом:
projection = d3.geo.orthographic()
    .scale(380)
    .rotate([0, 0])
    .translate([width / 2, height / 2])
    .clipAngle(90);

Библиотека D3 предоставляет два способа отображения геоданных - при помощи создания элементов векторной графики либо растровое отображение. Ввиду значительного количества объектов для отображения оптимально будет воспользоваться растровым отображением на элемент холста - canvas. Для реализации такого поведения следует заранее добавить на страницу HTML элемент canvas следующим кодом:
<canvas width="800" height="400"></canvas>
Здесь атрибуты width и height задают изначальные параметры ширины и высоты элемента.

Отображение графики на объекте холста происходит посредством объекта контекста. Он создаётся вызовом метода getContext объекта холста. Значит сперва следует получить объект холста, а затем создать контекст. Реализуем это следующим способом:
context = d3.select('#map canvas')
    .node()
    .getContext('2d', { alpha: false });
Здесь вызов d3.select создаёт выборку по css-селектору элемента холста, который затем получается непостредственно вызовом метода node. После чего создаётся двухмерный контекст с отключённым альфа-каналом для повышения производительности.

Процесс отображения геоданных посредством проекции на холст осуществляется вызовом соответствующих методов контекста холста с передачей им спроецированных точек. Модуль geo предосталяет удобный способ вызоват этих методов, скрывая все подробности. Это достигается созданием специальной функции-генератора, которая имея данные о способе процецирования точек, массив самих точек и контекст холста генерирует вызовы методов необходимых для правильного отображения переданных ей данных.
Создание такой функции-генератора осуществляется вызовом метода d3.geoPath с последующей настройкой полученной функции - установкой требуемой проекции и указания контекста. Это реализуется следующей цепочкой вызовов:
geoGenerator = d3.geoPath()
    .projection(projection)
    .context(context);


Было решено загружать геоданные асинхронным методом модуля queue. Как только данные будут загружены их следует обработать. Для того чтобы получить данные для обработки в тот момент когда они будут загружены используется механизм функций обратного вызова. В данном случае функцией обработки данных является processData. Передадим эту функцию методу await в качестве параметра. Таким образом функция processData будет вызвана в момент полной загрузки данных и ей будут переданы загруженные объекты в качестве параметров. Реализуется это следующим кодом:
queue()
    .defer(d3.json, "static/geo/topoworld.json")  
    .defer(d3.json, "static/geo/topolakes.json")  
    .defer(d3.json, "static/geo/toporivers.json")  
    .defer(d3.json, "static/geo/topocitybig.json")  
    .await(processData);


В процессе одного сеанса использования системы появляется необходимость получать погодные данные для разных городов. Значит требуется обеспечить возможность отправлять запросы и получать ответы от сервера без перезагрузки страницы. Было решено достичь это при помощи технологии AJAX. Для этого сперва необходимо создать объект запроса - XMLHttpRequest. Что выполняется вызовом соответствующего конструктора:
var xhr = new XMLHttpRequest();


var params = "lat=" + lat + "&lon=" + lon;
...

Основная информационная панель разделена на две части. При выборе города, указателем мыши или вводом названия, эта панель заполняется актуальной информацией. Данные для этип панелей загружаются в тот момент как понадобятся. 
В первую очередь нужно отображается название города и страны в которой он находится. Это помогает пользователю ориентироваться в информации. Под этими именами подписана информация второстепенной значимости - дата последнего обновления погодных данных по местному времени. Ниже располагается основаная информация - температура и погодные условия момент последнего обновления данных. Под актуальной температурой добавлен показатель ощущаемой температуры при наличных условиях.
Далее перечислены дополнительные значения погоды на данный момент, такие как направление и сила ветра, давление и влажность воздуха, а так же для городов расположенных близко к морям или океанам указана температура воды. Эти данные помогают лучше оценить обстановку в выбранном месте.
Все эти данные обновляются в момент получения ответа на AJAX запрос. Данные преобразуются в понятный пользователю вид и полученный текст обновляется в узлах HTML страницы. Данные требующие интерпретации, такие как погодные условия, преобразуются в иконки и добавляются в соответствующие элементы страницы.

------------------------------------------------------------------------------------------------------------------------
3.4 Кодирование программы серверного приложения и клиентской части веб-сервиса
(Тут описание общей структуры, подробная схема взаимодействия клиент-сервер, какие файлы с каким расширением у нас созданы, где сайт находится и всякое такое)

Клиентская часть получает необходимые ресурсы запрашивая их у серверной части и у 

Код серверной части на языке python находится в файле pogoda.py
Погодные данные кэшируются в файле weather.json

Общая структура файлов представлена в таблице

pogoda.py              Код сервера 
weather.json           Кэш погодных данных
templates/main.html    HTML файл страницы             
static->               Каталог ресурсов 
    style.css          Файл css стилей страницы     
    map.js             Клиентский скрипт отображения карты 
    weather.js         Клиентский скрипт обработки погодных данных     
    moment.js          Билиотека для работы с датами     
    moment-timezone-with-data-10-year-range.js   Модуль для работы с временными поясами
    favicon.ico        Иконка страницы         
    geo                Каталог обработанных геоданных в topoJSON формате
    icon               Каталог иконок в формате svg

Чтобы сервис был доступен с любого ПК подключённого к сети интернет необходим развернуть приложение на хостинге. Поскольку серверная часть написана на языке python требуется хостинг с поддержкой запуска веб-приложений на python. Обработку всех ресурсов берёт на себя серверное приложение, поэтому никаких других требований к хостингу нет. Значит подойдёт любой бесплатный хостинг. В качестве такого был выбран www.pythonanywhere.com имеющий удобные возможности разворачивания приложений с использованием микрофреймворка flask.


3.4.1  Кодирование серверного приложения
какие тут файлы, статика какая м прочее, как работает/взаимодействует с клиентом, что кодируем и зачем, вставить куски кода

Сервер хранит и выдаёт по запросу клиента HTML старницу со связанными содержимым - css стилями, javascript скриптами, topoJSON файлами геоданных, иконками погодных параметров.
Сервер обрабатывает запросы погодных данных от клиентов. В случае если данных по запрашиваемым координтам не имеется в кэше они будут получены путём обращения к API Яндекс.Погоды и сохранены в кэше.
Микрофреймворк flask обеспечивает весь необходимый функционал для разработки такого сервера. Первым делом необходимо импортировать необходимые функции и объекты из пакета flask. Это обеспечивается директивой import:
from flask import Flask, render_template, send_from_directory, request
Далее создаётся экземпляр класса Flask который и будет являться серверным приложением.
app = Flask(__name__)
В микрофреймворке flask в качестве механизма маршрутизации URL служит привязка функций к определённым URL. Для связи определённого URL c вызовом функции служит декоратор route созданного объекта app. Ему передаётся строка - правило URL. Например для связи функции с URL соответствующим главной странице достаточно вызвать декоратор следующим образом:
@app.route('/')
Сервер должен при запросе главной страницы отдвать HTML файл main.html который содержит разметку страницы. Для реализации этого поведения можно воспользоваться функцией render_template которой в качестве параметра передать имя файла:
render_template('main.html')
При использования этой функции flask ищет указаный файл в каталоге templates, поэтому файл main.html должен находиться в нём.
Функция render_template возвращает содержимое страницы которое должно быть передано в ответ на запрос главной страницы. В целом это поведение реализуется так:
@app.route('/')
def root():
    return render_template('main.html')

Необходимо реализовать передачу ресурсов из каталога static. Для этого предусмотрена функция send_from_directory, котораявозвращает файл из указанного каталога по указанному в параметре пути. Чтобы дать клиенту возможность запрашивать файл по любому пути из каталога static воспользуемся возможностью обработки параметров в правиле URL декоратора route. Требуемое поведение реализуется так:
@app.route('/static/<path:path>')
def send_static(path):
    return send_from_directory('static', path)
Здесь <path:path> это параметр пути который будет переда в функцию. Таким образом можно передавать любые ресурсы из каталога static.

Для выполнения запроса к API Яндекс.Погоды подключим модуль requests. Этот модуль предоставляет удобные методы для выполнения сетевых запросов. 

apikey
get

def get_weather_from_yandex(lat, lon):
    headers = {"X-Yandex-API-Key": YANDEX_WHEATHER_APIKEY}
    data = {"lat": lat, "lon": lon, "lang": "ru_RU", "limit": "1"}
    r = requests.get(YANDEX_WHEATHER_URL, headers=headers, params=data)
    return r.text


3.4.2   Кодирование клиентской части веб-сервиса
тут в начале о том что относится к клиенской части, что как зачем и далее уже подробнее про разные панели и прочее

Глобус с погодными данными отображется в браузере клиента значит ему необходимо получать все данные необходимые для этого, в том числе программные средства для реализации требуемого поведения. Клиент долже быть способен сам отобразить геоданные поэтому должен запрашивать файлы содержащие границы государств, рек, озёр и точки городов, а также файл javascript программы позволяющий запросить и отобразить эти данные. В данном случае этим файлом является map.js. Ещё клиент должен запрашивать погодные данные по выбираемым точкам и городам, следовательно необходимо иметь файл программы на языке javascript обеспечивающий запрос, обработку и отображение этих данных. В данном случае таким файлом является weather.js.




3.4.2.1 Панель с текущей погодной информацией
3.4.2.2  Панель прогноза 
3.4.2.3    .......
и т.д.

В различных местах нашей планеты восходи и заход солнца приходится на разное время, что означает что длительность светового дня разница от места к месту. Угол под которым приходит свет тоже зависти от местоположения, что влияет на долю ультрафиолетовой части спектра излучения. Эти параметры нужно учитывать отправляясь в другую часть света чтобы принять меры связанные с излишней или наоборот недостаточной инсоляцией. По этой причине на второй части основной панели выводится время восхода и заката, вычисленная долгота дня а также значение уф-индекса.

Если пользователю нужно будет знать погоду в ближайшие дни, то для этого предназначена панешь с прогнозом на 5 или 10 дней. На этой панели отображена краткая сводка погоды по дням - температура днём и облачность. Прогноз на 10 дней показывается по щелчку на соответсвующую кнопку. При щелчке на кнопку "На 5 дней" можно вернуть представления прогноза на 5 дней.
Для получения более подробного прогноза на какой-либо день предназначена панель детального прогноза. Данные в этой панели обновляются при щелчке мыши на соответсвующий день в панели прогноза на 5 или 10 дней.
Чтобы реализовать такое поведение, каждый элемент по которому можно щёлкнуть имеет уникальный идентификатор. Он необходим чтобы получить данный элемент страницы и привязать к нему обработчик щелчка мыши. А также чтобы реализовать смену стилей кнопок.
При щелчке на конекретный день прогноза имеющиеся погодные данные форматируются и отображаются на панели детального прогноза. Каждый элемент этой панели имеет свой идентификатор. При помощи которого в текстовом узле элемента обновляются данные. Например элемент отображающий уровень влажность утром имеет id равный morning_hum. У каждого элемента страницы может быть текстовое содержание. У jQuery объектов есть удобная функция для изменения этого текущего содержания - text. Таким образом значение влажности утром в прогнозе текущего дня может быть обновлено так:
$("#morning_hum").text(p.morning.humidity + "%");
Где p - переменная содержащая данные прогноза на выбранный день.

is_visible_dotp



3.3.2.4 Отображение названий стран
Будет проще ориентировать на глобусе если назавние каждой страны будет подписано. Но так как стран много, то отображать сразу все названия нецелесообразно. В геоданных стран имеется свойство ранга. Оно связано с масштабом при котором название страны имеет смысл отображать. Значит следует отображать лишь те названия стран у которых ранг меньше максимального ранга при данном масштабе. Более того, если страна не видна при текущем повороте глобуса то в таком случае её название не следует отображать. 

    Настройка размера шрифта и выравнивания текста по центру
    Настройка цвета текста и ширины линий
    1 Выбор очерднoй страны
        Вычисление центральной точки страны
        Вычисление максимального ранга страны с учётом мастштаба
        Если центральная точка страны видима И если ранг страны меньше максимального ранга
            да - Отобразить текст с названием страны в центральной точке
            нет - далее

        Последняя страна?
            нет - 1
            да - конец

3.3.2.5 Отображение городов
    Ранее было решено распределить все города на несколько уровней детализации. Поэтому список городов для отображения ограничивается несколькими уровнями в зависимости от текущего масштаба. Кроме того нет смысла отображать города которые находятся на обратной стороне глобуса при текущем повороте. Это приводи к тому, что для отображения городов необходимо получать списки городов вплоть до текущего максимального уровня, после чего проверять положение каждого города. И если город виден тогда отображать точку и название. Описанный алгоритм представлен на схеме (???)

    Установка размера шрифта
    Установка цвета текста и ширины линий
    Вычисление максимального уровня города на текущем масштабе
       1 Выбор списка городов очередного уровня 
            2 Выбор очередного города
            Отображение точки города
                Данный город виден при текущем повороте глобуса?
                    да - 
                        Получение экранных координат точки города
                        Вывод текста с именем города в полученных координатах
                    нет - далее
            
            Последний город в списке текущего уровня?
                нет - 2
                да - далее
        Текущий уровень меньше максимального?
            да - 1
            нет - далее
    Заливка цветом всех точек


Алгоритм формирования температурного почасового графика

0 Добавление погодных данных k-го часа в массив
Последний час?
    нет - 0
    да - дальше

    Расчёт минимальной и максимальной температуры в собранных данных
    Вычисление количества подписей для температуры
    Создание и настройка осей времени и температуры
    Установка областей значений и определения графика
    Создание температурной линии
    Создание и настройка SVG элемента
	Добавление линии температуры на график
	Добавление осей времени и температуры
    Добавление иконок условий погоды по точками температурной линии
    Настройка цветового градиента линии температуры



Чтобы отобразить функциональную зависимость температуры от времени. Для этого из имеющихся данных необходимо выбрать необходимые значения и сформировать массив точек. Дальше, сформируем элементы графика. Сперва необходимо создать оси времени и температуры. Чтобы график было проще воспринимать ось температуры должна содержать только те значения температуры которые принадлежат области значений графика. Чтобы этого добиться вычислим минимальную и максимальную температуру содержащуюся в собранных данных. После этого можно создать оси температуры и времени. Затем, по собранным данным построим линию температуры, настроим её цвет и толщину и добавим на график. Наконец, к каждой точки данных имеются погодные условия. Их можно отобразить иконками над соответствующими точками.

Графическое представление информации облегчает её восприятие. Имея данные прогноза за каждый час на несколько дней можно отобразить функциональную зависимость температуры от времени в виде графика. Чтобы было возможно читать данный график отобразим оси времени и температуры с подписанными значениями. 
Имея данные о погодных условиях в каждой точке можно отобразить иконки соответсвующих условий над этими точками.

Разработка графика
Отображение графика возможно средствами библиотеки D3.js, имеющей удобные средства для этого. 
Сперва следует собрать данные о температуре за каждый час и условиях в массив. Для этого обработаем почасовые погодные данные извлекая данные о температуре и иконке условий, формируя из них словарь. Абсциссой будет служить время с единицей измерения в 1 час. Ординатой будет служить температура соответствующая часу. Полученнй массив сохраним в переменой temp_data.
Чтобы задать границы по оси ординат вычислим минимальное и максимальное значение ординаты из полученного массива. Для этого воспользуемся функциями min и max библиотеки D3.js. Эти функции требуют в качестве аргументов массив значений. Поскольку в массиве содержатся объекты необходимо в качестве второго аргумента задать функцию выбора нужного поля из элемента массива. Получение минимального и максимального значения реализуем таким образом:
let temp_max = d3.max(temp_data, function(d) { return d.y; }); 
let temp_min = d3.min(temp_data, function(d) { return d.y; });

Вычислим количество делений оси ординат. Для этого найдём разность максимального и минимального значения. Эта разность и будет служить количеством делений. Но учётм, что при слишком малой разнице всеравно необходимо отображать несколько делений с подписями температуры. Поэтому добавим условие ограничивающее полученное значение тремя. А при слишком большом количестве делений подписи температуры будут пересекаться. Поэтому огранчим сверху количество делений значением в 12 делений. Реализация описанного вычисления приведена ниже:
let ticks = temp_max - temp_min;
if (ticks < 3) ticks = 3;
if (ticks > 12) ticks = 12;

Создание осей реализуется функцией axis модуля svg библиотеки D3.js. У созданной оси вызовом функции orient задётся её расположение. Создание оси абсцисс расположенной снизу реализуется таким образом:
var	xAxis = d3.svg.axis().scale(x).orient("bottom");

Созданную ось необходимо настроить. Сперва в качестве значений устанавливается массив часов. Эти значения необходимо преобразовать из номера часа в строку отражающую время этого часа. Это достигается вызовом функци tickFormat с функцией форматирования значения в качестве аргумента. Для создания сетки нужно установить высоту внутренних отметок делений по высоте графика. Это реализуется функцией innerTickSize. Настройка отступов подписей осуществляется функцией tickPadding. Полный код настройки оси приведён ниже:
xAxis.ticks(12)
    .tickFormat(function(d, i){
        let h = d % 24;
        return h + ":00";
        
    })
    .innerTickSize(-height)
    .outerTickSize(0)
    .tickValues(hours)
    .tickPadding(10);

Аналогично создаётся и настраивается ось ординат. В данном случае функция форматирования будет преобразовывать значение температуры в формат удобный для восприятия человеком. Так же настраивается ширина внутренних делений по ширине графика. Создание и настройка оси ординат реализуется так:
var	yAxis = d3.svg.axis().scale(y)
    .orient("left").ticks(ticks)
    .innerTickSize(-width)
    .outerTickSize(0)
    .tickPadding(5)
    .tickFormat(function(d, i){
        return human_temp_grad(d);
    });

Чтобы создать svg элемент представляющий линию температуры воспользуемся функцией line модуля svg. Если отразить линию по точкам данных как есть, то она будет ломаной. Необходимо сгладить линию. Для этого применим интерполяцию линии посредством вызова функции interpolate. Эта функция требует в качестве аргумента определить метод интерполяции. Для нашего случая подойдёт метод basis - интерполяция  b-сплайном с дублированием контрольных точек на концах отрезков. В итоге, создание линии температуры реализуется так:
var	valueline = d3.svg.line()
    .interpolate("basis")
    .x(function(d) { return x(d.x); })
    .y(function(d) { return y(d.y); });

Созданную линию добавим на координатную плоскость вызовом метода append:
svg.append("path")	
    .attr("class", "line")
    .attr("d", valueline(temp_data));


https://metanit.com/web/d3js/4.7.php
