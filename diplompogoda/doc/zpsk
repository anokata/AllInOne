Чтобы реализовать управление масштабом добавляются кнопки управления на страницу. Чтобы иметь возможность легко найти эти кнопки, устанавливаются значения аттрибута id. В HTML коде страницы кнопки выглядят следующим образом:
<input type=button value="+" id="scaleup" />
<input type=button value="-" id="scaledown" />

Далее, чтобы привязать поведение к нажатиям этих кнопок необходимо установить им значение аттрибута onclick. Этим значением будет функция, выполняющая соответственно увеличение или уменьшение масштаба. Для получения элементов кнопок воспользуемся jQuery функцией $ и передадим ей css селектор выбирающий требуемый элемент по аттрибуту id. У полученного jQuery объкта можно сразу вызвать метод on для привязки функции-обработчика на любое событие. В данном случае привязывается функция масштабирования на событие click. Данное действие выглядит следующим образом:
$("#scaleup").on("click", function() { scale_projection(SCALE_VAL) });
$("#scaledown").on("click", function() { scale_projection(-SCALE_VAL) });

Кроме возможности масштабирования нажатиями кнопок удобно это же действие продублировать на поворот колеса мыши. Событие поворота колеса мыши следует обрабатывать только на элементе карты чтобы не нарушать естественные функции этого события. 
Поскольку событие поворота колеса мыши было стандартизовано относительно недавно, разные браузры используют разные имена для него. Для обеспечения кроссбраузерности следует привязать функцию масштабирования на несколько событий. Этого можно достичь вызвом метода bind выбранного jQuery объекта с перечислением событий в строке в качестве параметра. 
Чтобы понимать направления поворота колеса мыши достаточно проверять знак значения смещения. Но это значение разное для разных браузеров. Следовательно нужно это учитывать и проверять их все. В итоге привязка на событие поворота колеса мыши выполняется так:
$("#map").bind('mousewheel DOMMouseScroll', function(event){
    if (event.originalEvent.wheelDelta > 0 || event.originalEvent.detail < 0) {
        scale_projection(SCALE_VAL/2);
    }
    else {
        scale_projection(-SCALE_VAL/2);
    }
});

https://desktop.arcgis.com/ru/arcmap/10.3/guide-books/map-projections/orthographic.htm
https://observablehq.com/collection/@d3/d3-geo

Географические данные содержат объекты представляющие собой множества точек с георафическими координатами - широтой и долготой. Нельзя напрямую отобразить эти точки на экране. Требуется преобразовать георафические координаты в экранные. Это можно сделать множеством способов, поэтому существует несколько картографических проекций. Для пользователя привычно видеть глобус в виде шара. Ближе всего к этому ортографическая проекция - которая является перспективной проекцией которая обозревает земной шар из бесконечности, что даёт реалистичную иллюзию трёхмерного глобуса.
Модуль geo библиотеки D3 содержит требуемую проекцию - d3.geo.orthographic. При помощи этой функции создаётся объект ортографической проекции. После чего следует настроить начальные параметры проекции. А именно установить масштаб - с помощью вызова метода scale, повернуть в нулевую точку с помощью метода rotate, переместить отображение в середину холста, установить угол отсечения вызовом метода clipAngle. Поскольку каждый вызов метода объекта d3 возвращает результирующий объект, то всё перечисленное можно организовать в цепочку вызовов. В итоге создание и настройка объекта проекции реализуется следующим вызовом:
projection = d3.geo.orthographic()
    .scale(380)
    .rotate([0, 0])
    .translate([width / 2, height / 2])
    .clipAngle(90);

Библиотека D3 предоставляет два способа отображения геоданных - при помощи создания элементов векторной графики либо растровое отображение. Ввиду значительного количества объектов для отображения оптимально будет воспользоваться растровым отображением на элемент холста - canvas. Для реализации такого поведения следует заранее добавить на страницу HTML элемент canvas следующим кодом:
<canvas width="800" height="400"></canvas>
Здесь атрибуты width и height задают изначальные параметры ширины и высоты элемента.

Отображение графики на объекте холста происходит посредством объекта контекста. Он создаётся вызовом метода getContext объекта холста. Значит сперва следует получить объект холста, а затем создать контекст. Реализуем это следующим способом:
context = d3.select('#map canvas')
    .node()
    .getContext('2d', { alpha: false });
Здесь вызов d3.select создаёт выборку по css-селектору элемента холста, который затем получается непостредственно вызовом метода node. После чего создаётся двухмерный контекст с отключённым альфа-каналом для повышения производительности.

Процесс отображения геоданных посредством проекции на холст осуществляется вызовом соответствующих методов контекста холста с передачей им спроецированных точек. Модуль geo предосталяет удобный способ вызоват этих методов, скрывая все подробности. Это достигается созданием специальной функции-генератора, которая имея данные о способе процецирования точек, массив самих точек и контекст холста генерирует вызовы методов необходимых для правильного отображения переданных ей данных.
Создание такой функции-генератора осуществляется вызовом метода d3.geoPath с последующей настройкой полученной функции - установкой требуемой проекции и указания контекста. Это реализуется следующей цепочкой вызовов:
geoGenerator = d3.geoPath()
    .projection(projection)
    .context(context);


Было решено загружать геоданные асинхронным методом модуля queue. Как только данные будут загружены их следует обработать. Для того чтобы получить данные для обработки в тот момент когда они будут загружены используется механизм функций обратного вызова. В данном случае функцией обработки данных является processData. Передадим эту функцию методу await в качестве параметра. Таким образом функция processData будет вызвана в момент полной загрузки данных и ей будут переданы загруженные объекты в качестве параметров. Реализуется это следующим кодом:
queue()
    .defer(d3.json, "static/geo/topoworld.json")  
    .defer(d3.json, "static/geo/topolakes.json")  
    .defer(d3.json, "static/geo/toporivers.json")  
    .defer(d3.json, "static/geo/topocitybig.json")  
    .await(processData);


В процессе одного сеанса использования системы появляется необходимость получать погодные данные для разных городов. Значит требуется обеспечить возможность отправлять запросы и получать ответы от сервера без перезагрузки страницы. Было решено достичь это при помощи технологии AJAX. Для этого сперва необходимо создать объект запроса - XMLHttpRequest. Что выполняется вызовом соответствующего конструктора:
var xhr = new XMLHttpRequest();


var params = "lat=" + lat + "&lon=" + lon;
...

Основная информационная панель разделена на две части. При выборе города, указателем мыши или вводом названия, эта панель заполняется актуальной информацией. Данные для этип панелей загружаются в тот момент как понадобятся. 
В первую очередь нужно отображается название города и страны в которой он находится. Это помогает пользователю ориентироваться в информации. Под этими именами подписана информация второстепенной значимости - дата последнего обновления погодных данных по местному времени. Ниже располагается основаная информация - температура и погодные условия момент последнего обновления данных. Под актуальной температурой добавлен показатель ощущаемой температуры при наличных условиях.
Далее перечислены дополнительные значения погоды на данный момент, такие как направление и сила ветра, давление и влажность воздуха, а так же для городов расположенных близко к морям или океанам указана температура воды. Эти данные помогают лучше оценить обстановку в выбранном месте.
Все эти данные обновляются в момент получения ответа на AJAX запрос. Данные преобразуются в понятный пользователю вид и полученный текст обновляется в узлах HTML страницы. Данные требующие интерпретации, такие как погодные условия, преобразуются в иконки и добавляются в соответствующие элементы страницы.


3.4 Кодирование программы серверного приложения и клиентской части веб-сервиса
(Тут описание общей структуры, подробная схема взаимодействия клиент-сервер, какие файлы с каким расширением у нас созданы, где сайт находится и всякое такое)

Клиентская часть получает необходимые ресурсы запрашивая их у серверной части и у 

Код серверной части на языке python находится в файле pogoda.py
Погодные данные кэшируются в файле weather.json

Общая структура файлов представлена в таблице

pogoda.py              Код сервера 
weather.json           Кэш погодных данных
templates/main.html    HTML файл страницы             
static->               Каталог ресурсов 
    style.css          Файл css стилей страницы     
    map.js             Клиентский скрипт отображения карты 
    weather.js         Клиентский скрипт обработки погодных данных     
    moment.js          Билиотека для работы с датами     
    moment-timezone-with-data-10-year-range.js   Модуль для работы с временными поясами
    favicon.ico        Иконка страницы         
    geo                Каталог обработанных геоданных в topoJSON формате
    icon               Каталог иконок в формате svg

Чтобы сервис был доступен с любого ПК подключённого к сети интернет необходим развернуть приложение на хостинге. Поскольку серверная часть написана на языке python требуется хостинг с поддержкой запуска веб-приложений на python. Обработку всех ресурсов берёт на себя серверное приложение, поэтому никаких других требований к хостингу нет. Значит подойдёт любой бесплатный хостинг. В качестве такого был выбран www.pythonanywhere.com имеющий удобные возможности разворачивания приложений с использованием микрофреймворка flask.


3.4.1  Кодирование серверного приложения
какие тут файлы, статика какая м прочее, как работает/взаимодействует с клиентом, что кодируем и зачем, вставить куски кода

Сервер хранит и выдаёт по запросу клиента HTML старницу со связанными содержимым - css стилями, javascript скриптами, topoJSON файлами геоданных, иконками погодных параметров.
Сервер обрабатывает запросы погодных данных от клиентов. В случае если данных по запрашиваемым координтам не имеется в кэше они будут получены путём обращения к API Яндекс.Погоды и сохранены в кэше.
Микрофреймворк flask обеспечивает весь необходимый функционал для разработки такого сервера. Первым делом необходимо импортировать необходимые функции и объекты из пакета flask. Это обеспечивается директивой import:
from flask import Flask, render_template, send_from_directory, request
Далее создаётся экземпляр класса Flask который и будет являться серверным приложением.
app = Flask(__name__)
В микрофреймворке flask в качестве механизма маршрутизации URL служит привязка функций к определённым URL. Для связи определённого URL c вызовом функции служит декоратор route созданного объекта app. Ему передаётся строка - правило URL. Например для связи функции с URL соответствующим главной странице достаточно вызвать декоратор следующим образом:
@app.route('/')
Сервер должен при запросе главной страницы отдвать HTML файл main.html который содержит разметку страницы. Для реализации этого поведения можно воспользоваться функцией render_template которой в качестве параметра передать имя файла:
render_template('main.html')
При использования этой функции flask ищет указаный файл в каталоге templates, поэтому файл main.html должен находиться в нём.
Функция render_template возвращает содержимое страницы которое должно быть передано в ответ на запрос главной страницы. В целом это поведение реализуется так:
@app.route('/')
def root():
    return render_template('main.html')

Необходимо реализовать передачу ресурсов из каталога static. Для этого предусмотрена функция send_from_directory, котораявозвращает файл из указанного каталога по указанному в параметре пути. Чтобы дать клиенту возможность запрашивать файл по любому пути из каталога static воспользуемся возможностью обработки параметров в правиле URL декоратора route. Требуемое поведение реализуется так:
@app.route('/static/<path:path>')
def send_static(path):
    return send_from_directory('static', path)
Здесь <path:path> это параметр пути который будет переда в функцию. Таким образом можно передавать любые ресурсы из каталога static.

Для выполнения запроса к API Яндекс.Погоды подключим модуль requests. Этот модуль предоставляет удобные методы для выполнения сетевых запросов. 

apikey
get

def get_weather_from_yandex(lat, lon):
    headers = {"X-Yandex-API-Key": YANDEX_WHEATHER_APIKEY}
    data = {"lat": lat, "lon": lon, "lang": "ru_RU", "limit": "1"}
    r = requests.get(YANDEX_WHEATHER_URL, headers=headers, params=data)
    return r.text


3.4.2   Кодирование клиентской части веб-сервиса
тут в начале о том что относится к клиенской части, что как зачем и далее уже подробнее про разные панели и прочее

Глобус с погодными данными отображется в браузере клиента значит ему необходимо получать все данные необходимые для этого, в том числе программные средства для реализации требуемого поведения. Клиент долже быть способен сам отобразить геоданные поэтому должен запрашивать файлы содержащие границы государств, рек, озёр и точки городов, а также файл javascript программы позволяющий запросить и отобразить эти данные. В данном случае этим файлом является map.js. Ещё клиент должен запрашивать погодные данные по выбираемым точкам и городам, следовательно необходимо иметь файл программы на языке javascript обеспечивающий запрос, обработку и отображение этих данных. В данном случае таким файлом является weather.js.




3.4.2.1 Панель с текущей погодной информацией
3.4.2.2  Панель прогноза 
3.4.2.3    .......
и т.д.

В различных местах нашей планеты восходи и заход солнца приходится на разное время, что означает что длительность светового дня разница от места к месту. Угол под которым приходит свет тоже зависти от местоположения, что влияет на долю ультрафиолетовой части спектра излучения. Эти параметры нужно учитывать отправляясь в другую часть света чтобы принять меры связанные с излишней или наоборот недостаточной инсоляцией. По этой причине на второй части основной панели выводится время восхода и заката, вычисленная долгота дня а также значение уф-индекса.

??Зачем прогноз нужен???
Прогноз на 10 дней показывается по щелчку на соответсвующую кнопку. При щелчке на кнопку "На 5 дней" можно вернуть представления прогноза на 5 дней.

is_visible_dotp



3.3.2.4 Отображение названий стран

    Настройка размера шрифта и выравнивания текста по центру
    Настройка цвета текста и ширины линий
    1 Выбор очерднoй страны
        Вычисление центральной точки страны
        Вычисление максимального ранга страны с учётом мастштаба
        Если центральная точка страны видима И если ранг страны меньше максимального ранга
            да - Отобразить текст с названием страны в центральной точке
            нет - далее

        Последняя страна?
            нет - 1
            да - конец

3.3.2.5 Отображение городов

    Установка размера шрифта
    Установка цвета текста и ширины линий
    Вычисление максимального уровня города на текущем масштабе
       1 Выбор списка городов очередного уровня 
            2 Выбор очередного города
            Отображение точки города
                Данный город виден при текущем повороте глобуса?
                    да - 
                        Получение экранных координат точки города
                        Вывод текста с именем города в полученных координатах
                    нет - далее
            
            Последний город в списке текущего уровня?
                нет - 2
                да - далее
        Текущий уровень меньше максимального?
            да - 1
            нет - далее
    Заливка цветом всех точек

