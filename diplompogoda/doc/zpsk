Чтобы реализовать управление масштабом добавляются кнопки управления на страницу. Чтобы иметь возможность легко найти эти кнопки, устанавливаются значения аттрибута id. В HTML коде страницы кнопки выглядят следующим образом:
<input type=button value="+" id="scaleup" />
<input type=button value="-" id="scaledown" />

Далее, чтобы привязать поведение к нажатиям этих кнопок необходимо установить им значение аттрибута onclick. Этим значением будет функция, выполняющая соответственно увеличение или уменьшение масштаба. Для получения элементов кнопок воспользуемся jQuery функцией $ и передадим ей css селектор выбирающий требуемый элемент по аттрибуту id. У полученного jQuery объкта можно сразу вызвать метод on для привязки функции-обработчика на любое событие. В данном случае привязывается функция масштабирования на событие click. Данное действие выглядит следующим образом:
$("#scaleup").on("click", function() { scale_projection(SCALE_VAL) });
$("#scaledown").on("click", function() { scale_projection(-SCALE_VAL) });

Кроме возможности масштабирования нажатиями кнопок удобно это же действие продублировать на поворот колеса мыши. Событие поворота колеса мыши следует обрабатывать только на элементе карты чтобы не нарушать естественные функции этого события. 
Поскольку событие поворота колеса мыши было стандартизовано относительно недавно, разные браузры используют разные имена для него. Для обеспечения кроссбраузерности следует привязать функцию масштабирования на несколько событий. Этого можно достичь вызвом метода bind выбранного jQuery объекта с перечислением событий в строке в качестве параметра. 
Чтобы понимать направления поворота колеса мыши достаточно проверять знак значения смещения. Но это значение разное для разных браузеров. Следовательно нужно это учитывать и проверять их все. В итоге привязка на событие поворота колеса мыши выполняется так:
$("#map").bind('mousewheel DOMMouseScroll', function(event){
    if (event.originalEvent.wheelDelta > 0 || event.originalEvent.detail < 0) {
        scale_projection(SCALE_VAL/2);
    }
    else {
        scale_projection(-SCALE_VAL/2);
    }
});

https://desktop.arcgis.com/ru/arcmap/10.3/guide-books/map-projections/orthographic.htm
https://observablehq.com/collection/@d3/d3-geo

Географические данные содержат объекты представляющие собой множества точек с георафическими координатами - широтой и долготой. Нельзя напрямую отобразить эти точки на экране. Требуется преобразовать георафические координаты в экранные. Это можно сделать множеством способов, поэтому существует несколько картографических проекций. Для пользователя привычно видеть глобус в виде шара. Ближе всего к этому ортографическая проекция - которая является перспективной проекцией которая обозревает земной шар из бесконечности, что даёт реалистичную иллюзию трёхмерного глобуса.
Модуль geo библиотеки D3 содержит требуемую проекцию - d3.geo.orthographic. При помощи этой функции создаётся объект ортографической проекции. После чего следует настроить начальные параметры проекции. А именно установить масштаб - с помощью вызова метода scale, повернуть в нулевую точку с помощью метода rotate, переместить отображение в середину холста, установить угол отсечения вызовом метода clipAngle. Поскольку каждый вызов метода объекта d3 возвращает результирующий объект, то всё перечисленное можно организовать в цепочку вызовов. В итоге создание и настройка объекта проекции реализуется следующим вызовом:
projection = d3.geo.orthographic()
    .scale(380)
    .rotate([0, 0])
    .translate([width / 2, height / 2])
    .clipAngle(90);

Библиотека D3 предоставляет два способа отображения геоданных - при помощи создания элементов векторной графики либо растровое отображение. Ввиду значительного количества объектов для отображения оптимально будет воспользоваться растровым отображением на элемент холста - canvas. Для реализации такого поведения следует заранее добавить на страницу HTML элемент canvas следующим кодом:
<canvas width="800" height="400"></canvas>
Здесь атрибуты width и height задают изначальные параметры ширины и высоты элемента.

Отображение графики на объекте холста происходит посредством объекта контекста. Он создаётся вызовом метода getContext объекта холста. Значит сперва следует получить объект холста, а затем создать контекст. Реализуем это следующим способом:
context = d3.select('#map canvas')
    .node()
    .getContext('2d', { alpha: false });
Здесь вызов d3.select создаёт выборку по css-селектору элемента холста, который затем получается непостредственно вызовом метода node. После чего создаётся двухмерный контекст с отключённым альфа-каналом для повышения производительности.

Процесс отображения геоданных посредством проекции на холст осуществляется вызовом соответствующих методов контекста холста с передачей им спроецированных точек. Модуль geo предосталяет удобный способ вызоват этих методов, скрывая все подробности. Это достигается созданием специальной функции-генератора, которая имея данные о способе процецирования точек, массив самих точек и контекст холста генерирует вызовы методов необходимых для правильного отображения переданных ей данных.
Создание такой функции-генератора осуществляется вызовом метода d3.geoPath с последующей настройкой полученной функции - установкой требуемой проекции и указания контекста. Это реализуется следующей цепочкой вызовов:
geoGenerator = d3.geoPath()
    .projection(projection)
    .context(context);


Было решено загружать геоданные асинхронным методом модуля queue. Как только данные будут загружены их следует обработать. Для того чтобы получить данные для обработки в тот момент когда они будут загружены используется механизм функций обратного вызова. В данном случае функцией обработки данных является processData. Передадим эту функцию методу await в качестве параметра. Таким образом функция processData будет вызвана в момент полной загрузки данных и ей будут переданы загруженные объекты в качестве параметров. Реализуется это следующим кодом:
queue()
    .defer(d3.json, "static/geo/topoworld.json")  
    .defer(d3.json, "static/geo/topolakes.json")  
    .defer(d3.json, "static/geo/toporivers.json")  
    .defer(d3.json, "static/geo/topocitybig.json")  
    .await(processData);





